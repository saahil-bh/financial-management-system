-- user table 
CREATE TABLE Users (
    u_id uuid PRIMARY KEY NOT NULL,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    role VARCHAR(10) CHECK (role IN ('Admin', 'User')) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
	address TEXT
);

-- quotation table 
CREATE TABLE Quotations(
	q_id SERIAL PRIMARY KEY,
	user_id uuid REFERENCES Users(u_id) ON DELETE CASCADE, -- to make sure all quotations by THE user are all deleted.
	status VARCHAR(30) NOT NULL DEFAULT 'Draft' CHECK (status IN ('Draft', 'Submitted', 'Approved', 'Rejected')) ,
	total NUMERIC(12,2) NOT NULL, -- make sure 0.1 + 0.2 = 0.30 not 0.300000,
	tax NUMERIC(6,2) DEFAULT 0.00,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL, 
	updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- Invoice
CREATE TABLE Invoices(
	i_id SERIAL PRIMARY KEY,
	q_id INT NULL REFERENCES Quotations(q_id) ON DELETE SET NULL, -- not cascade as to keep finance his 
	status VARCHAR(30) NOT NULL DEFAULT 'Draft' CHECK (status IN ('Draft', 'Submitted', 'Approved', 'Rejected', 'Paid')),
	total NUMERIC(12,2) NOT NULL,
	due_date DATE NOT NULL,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL, 
	updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
	u_id uuid REFERENCES Users(u_id) ON DELETE SET NULL
);

-- Receipt
CREATE TABLE Receipts(
	r_id SERIAL PRIMARY KEY,
	i_id INT NULL REFERENCES Invoices(i_id) ON DELETE SET NULL, 
	payment_date DATE NOT NULL,
	amount NUMERIC(12,2) NOT NULL,
	status VARCHAR(20) DEFAULT 'Pending' CHECK (status IN ('Pending', 'Approved', 'Rejected', 'Submitted')) NOT NULL,
	u_id uuid REFERENCES Users(u_id) ON DELETE SET NULL,
	payment_method VARCHAR(20) CHECK (payment_method IN ('Bank Transfer', 'Cash', 'Credit Card'))
);

-- Notification
CREATE TABLE Notifications(
	n_id SERIAL PRIMARY KEY,
	u_id uuid REFERENCES Users(u_id) ON DELETE CASCADE, 
	message TEXT NOT NULL,
	type VARCHAR(30) NOT NULL CHECK (type IN ('LINE', 'Email')),
	created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- Logs
CREATE TABLE Logs(
	l_id SERIAL PRIMARY KEY,
	action VARCHAR(100) NOT NULL,
	actor_id uuid NULL REFERENCES Users(u_id) ON DELETE SET NULL,
	document_id INT,
	timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

CREATE TABLE CompanyProfile (
  company_id SERIAL PRIMARY KEY,
  company_name VARCHAR(255),
  company_address TEXT,
  tax_id VARCHAR(50),
  phone VARCHAR(50),
  email VARCHAR(100)
);

CREATE TABLE CompanyBankAccount (
  bank_id SERIAL PRIMARY KEY,
  bank_name VARCHAR(100),
  account_name VARCHAR(100),
  account_number VARCHAR(50),
  swift_code VARCHAR(20),
  is_default BOOLEAN DEFAULT TRUE
);

CREATE TABLE QuotationItems (
  item_id SERIAL PRIMARY KEY,
  q_id INT REFERENCES Quotations(q_id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  quantity INT NOT NULL,
  unit_price NUMERIC(12,2) NOT NULL,
  total NUMERIC(12,2) GENERATED ALWAYS AS (quantity * unit_price) STORED
);

CREATE TABLE InvoiceItems (
  inv_item_id SERIAL PRIMARY KEY,
  i_id INT REFERENCES Invoices(i_id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  quantity INT NOT NULL,
  unit_price NUMERIC(12,2) NOT NULL,
  total NUMERIC(12,2) GENERATED ALWAYS AS (quantity * unit_price) STORED
);

CREATE INDEX idx_user_role ON users(role);
CREATE INDEX idx_quotation_status ON quotations(status);
CREATE INDEX idx_invoice_status ON invoices(status);
CREATE INDEX idx_log_actor ON logs(actor_id);

---------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.fn_log_quotation_changes()
  RETURNS TRIGGER
AS $$
DECLARE
  log_action VARCHAR;
  doc_id INT;
  actor_id_from_row uuid;
BEGIN
  -- On INSERT (Create)
  IF (TG_OP = 'INSERT') THEN
    doc_id := NEW.q_id;
    actor_id_from_row := NEW.user_id; -- Get user from the new row
    log_action := 'Quotation ' || doc_id || ' created with status ' || NEW.status;

    INSERT INTO logs (action, actor_id, document_id)
    VALUES (log_action, actor_id_from_row, doc_id);

    RETURN NEW;

  -- On UPDATE (Status change, etc.)
  ELSIF (TG_OP = 'UPDATE') THEN
    doc_id := NEW.q_id;
    actor_id_from_row := NEW.user_id; -- Get user from the updated row

    -- This is the key part from your spec!
    -- Only log if the status has *actually changed*.
    IF NEW.status <> OLD.status THEN
      log_action := 'Quotation ' || doc_id || ' status changed from ' || OLD.status || ' to ' || NEW.status;
      
      INSERT INTO logs (action, actor_id, document_id)
      VALUES (log_action, actor_id_from_row, doc_id);
    END IF;

    RETURN NEW;

  -- On DELETE
  ELSIF (TG_OP = 'DELETE') THEN
    doc_id := OLD.q_id;
    actor_id_from_row := OLD.user_id; -- Get user from the old row being deleted
    log_action := 'Quotation ' || doc_id || ' deleted.';
    
    INSERT INTO logs (action, actor_id, document_id)
    VALUES (log_action, actor_id_from_row, doc_id);

    RETURN OLD;

  END IF;

  RETURN NULL; 
END;
$$
LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_quotation_log ON Quotations;


CREATE TRIGGER tr_quotation_log

  AFTER INSERT OR UPDATE OR DELETE ON Quotations
 
  FOR EACH ROW
  
  EXECUTE FUNCTION public.fn_log_quotation_changes();
---------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.fn_log_invoice_changes()
  RETURNS TRIGGER
AS $$
DECLARE
  log_action TEXT;
  doc_id INT;
  actor_id_from_row UUID;
BEGIN
  -- On INSERT (When a new invoice is created)
  IF (TG_OP = 'INSERT') THEN
    doc_id := NEW.i_id;
    actor_id_from_row := NEW.u_id;
    log_action := 'Invoice ' || doc_id || ' created with status ' || NEW.status;

    INSERT INTO logs (action, actor_id, document_id, timestamp)
    VALUES (log_action, actor_id_from_row, doc_id, NOW());

    RETURN NEW;

  -- On UPDATE (When invoice status or info changes)
  ELSIF (TG_OP = 'UPDATE') THEN
    doc_id := NEW.i_id;
    actor_id_from_row := NEW.u_id;

    -- Only log if the status actually changes
    IF NEW.status IS DISTINCT FROM OLD.status THEN
      log_action := 'Invoice ' || doc_id ||
                    ' status changed from ' || OLD.status ||
                    ' to ' || NEW.status;

      INSERT INTO logs (action, actor_id, document_id, timestamp)
      VALUES (log_action, actor_id_from_row, doc_id, NOW());
    END IF;

    RETURN NEW;


  -- On DELETE (When invoice is deleted)

  ELSIF (TG_OP = 'DELETE') THEN
    doc_id := OLD.i_id;
    actor_id_from_row := OLD.u_id;
    log_action := 'Invoice ' || doc_id || ' deleted.';

    INSERT INTO logs (action, actor_id, document_id, timestamp)
    VALUES (log_action, actor_id_from_row, doc_id, NOW());

    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Recreate the trigger
DROP TRIGGER IF EXISTS tr_invoice_log ON Invoices;

CREATE TRIGGER tr_invoice_log
  AFTER INSERT OR UPDATE OR DELETE ON Invoices
  FOR EACH ROW
  EXECUTE FUNCTION public.fn_log_invoice_changes();
---------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.fn_log_receipt_changes()
  RETURNS TRIGGER
AS $$
DECLARE
  log_action VARCHAR;
  doc_id INT;
  actor_id_from_row uuid;
BEGIN
  -- On INSERT (Create)
  IF (TG_OP = 'INSERT') THEN
    doc_id := NEW.r_id;
    actor_id_from_row := NEW.u_id;
    log_action := 'Receipt ' || doc_id || ' created with status ' || NEW.status;

    INSERT INTO logs (action, actor_id, document_id, timestamp)
    VALUES (log_action, actor_id_from_row, doc_id, NOW());

    RETURN NEW;

  -- On UPDATE (Status change: Confirmed, Rejected)
  ELSIF (TG_OP = 'UPDATE') THEN
    doc_id := NEW.r_id;
    actor_id_from_row := NEW.u_id;

    -- Only log if the status has actually changed (IS DISTINCT FROM handles NULL values safely)
    IF NEW.status IS DISTINCT FROM OLD.status THEN
      log_action := 'Receipt ' || doc_id || ' status changed from ' || OLD.status || ' to ' || NEW.status;
      
      -- Optional: Create a more human-readable action for confirmation/rejection
      IF NEW.status IN ('Confirmed', 'Rejected') THEN
          log_action := 'Receipt ' || doc_id || ' was ' || NEW.status || '.';
      END IF;

      INSERT INTO logs (action, actor_id, document_id, timestamp)
      VALUES (log_action, actor_id_from_row, doc_id, NOW());
    END IF;

    RETURN NEW;

  -- On DELETE
  ELSIF (TG_OP = 'DELETE') THEN
    doc_id := OLD.r_id;
    actor_id_from_row := OLD.u_id;
    log_action := 'Receipt ' || doc_id || ' deleted.';

    INSERT INTO logs (action, actor_id, document_id, timestamp)
    VALUES (log_action, actor_id_from_row, doc_id, NOW());

    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_receipt_log ON receipts;

CREATE TRIGGER tr_receipt_log
  -- Run this function AFTER any of these actions
  AFTER INSERT OR UPDATE OR DELETE ON Receipts
  -- Run it once for each row that was changed
  FOR EACH ROW
  -- Call the function we just created
  EXECUTE FUNCTION public.fn_log_receipt_changes();
---------------------------------------------------------------------------------------------------------------
